import { bytesToUtf8, EncryptionKey, utf8ToBytes } from '@meeco/cryppo';
import cryppo from '../services/cryppo-service';

export const SYMMETRIC_KEY_LENGTH = 32;
const SYMMETRIC_KEY_STRATEGY = cryppo.CipherStrategy.AES_GCM;

/**
 * Meeco password-derived, key-encryption and data-encryption keys are all symmetric keys (there is one key
 * that is used to both encrypt and decrypt things).
 *
 * This wrapper ensures that keys can be safely serialized as JSON (by encoding them as URL-Safe Base64)
 * and avoids confusion when dealing with converting to and from this encoded format, as well as encrypting
 * UTF-8 strings or other keys.
 */
export class SymmetricKey {
  // This describes the base64 format defined by cryppo.encodeSafe64
  private static base64RE = /^[a-zA-Z0-9\-_=]*$/;

  /**
   * The constructor is intentionally private as we want the user to be explicit as to whether the value coming
   * in is raw bytes or a base64 encoded version.
   *
   * @param _key  Value as binary string. Avoid outputting to console but should be used for actual encryption.
   */
  private constructor(private readonly _key: EncryptionKey) {
    if (!_key) {
      throw new Error('Empty encryption key!');
    }
  }

  /** A new, random symmetric key with default length. */
  static generate(length = SYMMETRIC_KEY_LENGTH): SymmetricKey {
    return new SymmetricKey(EncryptionKey.generateRandom(length));
  }

  /**
   * Create a {@link SymmetricKey} from encoded URL-safe base 64 version of the key.
   * Use this for keys received via API calls or printed from the CLI.
   */
  static fromSerialized(value: string) {
    if (!value) {
      throw new Error('Symmetric Key cannot be constructed from an empty string');
    }

    if (!value.match(SymmetricKey.base64RE)) {
      throw new Error(`Serialized key ${value} did not match base64 format`);
    }

    return new SymmetricKey(EncryptionKey.fromSerialized(value));
  }

  static fromBytes(bytes: Uint8Array) {
    return new SymmetricKey(EncryptionKey.fromBytes(bytes));
  }

  static fromCryppoKey(key: EncryptionKey) {
    return new SymmetricKey(key);
  }

  /**
   * @returns The raw encryption key as a byte string.
   */
  get key() {
    return this._key.bytes;
  }

  /**
   * Implicitly called by `JSON.stringify()` to ensure that the value is safely printable
   */
  toJSON() {
    return this._key.serialize;
  }

  /**
   * Used to encrypt user-entered data such as birthdays or name.
   * Should *not* be used to encrypt keys - use {@link encryptKey} instead.
   * Empty string input will produce a null result.
   * @returns Base 64 encoded encrypted string.
   */
  async encryptString(value: string | null): Promise<string | null> {
    if (value === null || value === '') {
      return null;
    }
    return cryppo
      .encryptWithKey({
        data: utf8ToBytes(value),
        key: this._key,
        strategy: SYMMETRIC_KEY_STRATEGY,
      })
      .then(result => result.serialized);
  }

  /**
   * Used to encrypt generated bytes such as encryption keys or verification keys.
   * N.B.. Encryption keys are considered binary data even though they are often represented as strings.
   * @returns Base 64 encoded encrypted string.
   */
  async encryptKey(key: { key: Uint8Array }): Promise<string> {
    return cryppo
      .encryptWithKey({
        data: key.key,
        key: this._key,
        strategy: SYMMETRIC_KEY_STRATEGY,
      })
      .then(result => result.serialized!);
  }

  /**
   * Used to decrypt user-entered data such as birthdays or name.
   * Should *not* be used to decrypt keys - use {@link decryptKey} instead.
   *
   * Accepts string or null for compatibility with API return types, and returns
   * null only when input is null.
   */
  async decryptString(serialized: string | null): Promise<string | null> {
    if (serialized === null) {
      return null;
    }

    return cryppo
      .decryptWithKey({
        key: this._key,
        serialized,
      })
      .then(result => (result === null ? result : bytesToUtf8(result)));
  }

  /**
   * Used to decrypt generated bytes such as encryption keys or verification keys.
   * N.B.. Encryption keys are considered binary data even though they are often represented as strings
   */
  async decryptKey(serialized: string): Promise<SymmetricKey> {
    return cryppo
      .decryptWithKey({
        key: this._key,
        serialized,
      })
      .then(result => new SymmetricKey(EncryptionKey.fromBytes(result!)));
  }
}
